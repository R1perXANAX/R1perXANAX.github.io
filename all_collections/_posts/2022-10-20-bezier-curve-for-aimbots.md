---
layout: post
title: Bezier Curve to humanize Aimbots
date: 2022-10-20
categories: ["tutorials", "game hacking"]
---


**PREREQUISITES:** [Basic understand of Linear Interpolation](https://www.youtube.com/watch?v=qJq7I2DLGzI).


##### What are Bezier Curves?

A set of discrete "control points" defines a smooth, continuous curve by means of a formula. 
(From wiki: [https://en.wikipedia.org/wiki/Bézier_curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve))



##### How the curve is generated?

![Bezier curve](https://cdn.discordapp.com/attachments/983822321154396200/1032699314381787206/bezier_quadratic.gif)

From the gif animation we can see that the curve is basically a combination of Linear Interpolation between 3 segments. 
- P0 -> P1 
- P1 -> P2
- the dynamic segments at time(t) generated by that interpolation(the green one).
**The green segment defines the curve.**
So the formula to calculate a point given a time (t) is : 

![Curve fromula](https://cdn.discordapp.com/attachments/983822321154396200/1032699012580646954/unknown.png)

pasted from [here](https://www.gamedeveloper.com/business/how-to-work-with-bezier-curve-in-games-with-unity)



##### How I calculate time t or what even is time t?

The important thing is that you have to consider t as a variable and we can see it like a percentage of completion. It’s crucial that if t = 1 we have reached the end. So we can iterate as many times as we like, as long as t is <1

Why does t end with 1?
Substitute 1 for t in the formula. We have P(1) = (1-1)^2 x P0 + 2 x (1-1) x 1 x P1 + 1^2 x P2 = 0 + 0+ 1 x P2 = P2

That’s why!



**Before seeing the code let's analyze for a second the 3 fundamental points to generate the curve.**

- P0 = start view angles
- P1 = middle point or random point: P1 allows us to change the shape of the curve as we like, which is why it should be randomized. If you look in the gif it is exactly in the middle and the generated curve is a simple parabola. By moving P1 we can change the shape of our curve and therefore its movement.
- P2 = the final view angles

>P1 should be randomized to make sure that every curve is different. If every movement is equal it’s easy to detect!


>**NOTE**: In my example I used a static P1 so the curve is always the same: you should make a better version with randomized P1 (you could use a range of values, in order not to exceed too much from the distance of the target) and also you should  randomize the delay.






#### Code

I defined angles as a Vector2 with some overloaded operators
```cpp
class Vector2 {
	public:
		float x, y;

	public:
		Vector2();
		Vector2(float x, float y);
		inline Vector2 operator+(const Vector2& other);
		inline Vector2 operator-(const Vector2& other);
		inline Vector2 operator*(const Vector2& other);
		inline Vector2 operator*(const float other);
		inline Vector2 operator/(const Vector2& other);
		virtual void Normalize();
		virtual float Magnitude();
		float Distance(Vector2 to);
	};
```

The first function simply calculates the angles at time t

```cpp
Vector2 _Math::QuadraticBezier(Vector2 from, Vector2 to, Vector2 midPoint, float t) {
	return from * powf((1-t),2) + midPoint * 2 * (1 - t) * t + to* powf(t,2);
}
```

This function returns a Vector2 which corresponds to our wanted angles at time t. We have to assign the result of this function to the players viewAngles.

Now let’s write a for loop. Here is an example from my Battlefield4 cheat

```cpp
int randValue = distribution1(generator);
for (int t = 0;t <= 80; i+=0.0125) {
                        
    setAngles = _Math::QuadraticBezier(startAng, endAng, { startAng.x + (endAng.x - startAng.x) / randValue , endAng.y }, t);

    SetPitch(ToRadians(setAngles.x));

    SetYaw(ToRadians(setAngles.y));

    std::this_thread::sleep_for(std::chrono::milliseconds(distribution(generator)));
}
```


##### Explaination

- **Why I’m incrementing t by 0.0125?**
Cause I have 80 loops and 80*0.0125 = 1. If you make 100 loops t should be incremented by 0.01 and so on. more loops = more smoothness.

- **midPoint**
```cpp
{ startAng.x + (endAng.x - startAng.x) / randValue , endAng.y }
```
As you can see here I used a static midPoint ( EDIT: I randomized the offset value, dividing the distance with a random value from the distribution).
x refers to the pitch axis, so from a 2D view it refers to the Y axis( Up Down view).
You can randomize that point as you like.

>**NOTE:** It may require some mathematical correction to avoid weird aimbot  behavior. It depends on the game. Here you have to use YOUR brain, correct and adapt to your game.

- **Set the result**
```cpp
SetPitch(ToRadians(setAngles.x));
SetYaw(ToRadians(setAngles.y));
```
This is a function that sets the result of QuadraticBezierCurve to the localPlayer view angles
Here you have to do:
localplayer→viewAngle = calculatedViewAngles

- **Delay**
This is the time between each calculation, should be randomized. I used a distribution to randomize delay milliseconds between 1 and 3. 
```cpp
std::this_thread::sleep_for(std::chrono::milliseconds(distribution(generator)));
```

- **startAngle**
is the current viewAngle. Make sure to pass updated one on every call to QuadraticBezier.

- **endAngle**
is the wantedAngle (enemy head). This is the same for every calls



--- 

NOW IT’S YOUR TIME. UNDERSTANDING THIS GIVES YOU THE ABILITY TO ADAPT IN EVERY AIMBOTS. THIS IS A PSEUDO VERSION, YOU SHOULD IMPROVE IT.

THANKS FOR FOLLOWING.

**R1perXNX**